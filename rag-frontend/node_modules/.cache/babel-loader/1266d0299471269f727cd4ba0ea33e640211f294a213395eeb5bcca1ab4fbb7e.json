{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { env } from '../../../utils/process.mjs';\nimport { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\nfunction useViewport(_a) {\n  _s();\n  var visualElement = _a.visualElement,\n    whileInView = _a.whileInView,\n    onViewportEnter = _a.onViewportEnter,\n    onViewportLeave = _a.onViewportLeave,\n    _b = _a.viewport,\n    viewport = _b === void 0 ? {} : _b;\n  var state = useRef({\n    hasEnteredView: false,\n    isInView: false\n  });\n  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n  var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\n_s(useViewport, \"2pwVZgabXT4OwO9xAxCI62B/o1g=\", false, function () {\n  return [useObserver];\n});\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\n  _s2();\n  var root = _a.root,\n    rootMargin = _a.margin,\n    _b = _a.amount,\n    amount = _b === void 0 ? \"some\" : _b,\n    once = _a.once;\n  useEffect(function () {\n    if (!shouldObserve) return;\n    var options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin: rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    var intersectionCallback = function (entry) {\n      var _a;\n      var isIntersecting = entry.isIntersecting;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (state.isInView === isIntersecting) return;\n      state.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, isIntersecting);\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      var props = visualElement.getProps();\n      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback === null || callback === void 0 ? void 0 : callback(entry);\n    };\n    return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\n_s2(useIntersectionObserver, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\n  _s3();\n  var _b = _a.fallback,\n    fallback = _b === void 0 ? true : _b;\n  useEffect(function () {\n    if (!shouldObserve || !fallback) return;\n    if (env !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    /**\n     * Fire this in an rAF because, at this point, the animation state\n     * won't have flushed for the first time and there's certain logic in\n     * there that behaves differently on the initial animation.\n     *\n     * This hook should be quite rarely called so setting this in an rAF\n     * is preferred to changing the behaviour of the animation state.\n     */\n    requestAnimationFrame(function () {\n      var _a;\n      state.hasEnteredView = true;\n      var onViewportEnter = visualElement.getProps().onViewportEnter;\n      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\n      (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, true);\n    });\n  }, [shouldObserve]);\n}\n_s3(useMissingIntersectionObserver, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nexport { useViewport };","map":{"version":3,"names":["env","useRef","useEffect","AnimationType","warnOnce","observeIntersection","useViewport","_a","_s","visualElement","whileInView","onViewportEnter","onViewportLeave","_b","viewport","state","hasEnteredView","isInView","shouldObserve","Boolean","once","current","useObserver","IntersectionObserver","useMissingIntersectionObserver","useIntersectionObserver","thresholdNames","some","all","_s2","root","rootMargin","margin","amount","options","threshold","intersectionCallback","entry","isIntersecting","animationState","setActive","InView","props","getProps","callback","getInstance","_s3","fallback","requestAnimationFrame"],"sources":["A:/RAG/rag-frontend/src/node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs"],"sourcesContent":["import { env } from '../../../utils/process.mjs';\nimport { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nfunction useViewport(_a) {\n    var visualElement = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;\n    var state = useRef({\n        hasEnteredView: false,\n        isInView: false,\n    });\n    var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n    if (viewport.once && state.current.hasEnteredView)\n        shouldObserve = false;\n    var useObserver = typeof IntersectionObserver === \"undefined\"\n        ? useMissingIntersectionObserver\n        : useIntersectionObserver;\n    useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n    some: 0,\n    all: 1,\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? \"some\" : _b, once = _a.once;\n    useEffect(function () {\n        if (!shouldObserve)\n            return;\n        var options = {\n            root: root === null || root === void 0 ? void 0 : root.current,\n            rootMargin: rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        var intersectionCallback = function (entry) {\n            var _a;\n            var isIntersecting = entry.isIntersecting;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (state.isInView === isIntersecting)\n                return;\n            state.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && state.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                state.hasEnteredView = true;\n            }\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, isIntersecting);\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            var props = visualElement.getProps();\n            var callback = isIntersecting\n                ? props.onViewportEnter\n                : props.onViewportLeave;\n            callback === null || callback === void 0 ? void 0 : callback(entry);\n        };\n        return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n    }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var _b = _a.fallback, fallback = _b === void 0 ? true : _b;\n    useEffect(function () {\n        if (!shouldObserve || !fallback)\n            return;\n        if (env !== \"production\") {\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n        }\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won't have flushed for the first time and there's certain logic in\n         * there that behaves differently on the initial animation.\n         *\n         * This hook should be quite rarely called so setting this in an rAF\n         * is preferred to changing the behaviour of the animation state.\n         */\n        requestAnimationFrame(function () {\n            var _a;\n            state.hasEnteredView = true;\n            var onViewportEnter = visualElement.getProps().onViewportEnter;\n            onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, true);\n        });\n    }, [shouldObserve]);\n}\n\nexport { useViewport };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}